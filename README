CS 572 Class Project, Fall 2010 at Portland State University
============================================================

The objective is to develop a general purpose driver for the teensy
micro-controller that exposes a series of abstract character devices
in userland. These devices will control various aspects of the teensy
for a variety of purposes. The idea is that a simple set of ioctls,
along with reads and writes can provide general purpose functionality
without fiddly access to the teensy directly.

Repository
==========

Branches
--------

* master
* reader: Andrew's teensy_read() branch

Git Cheat Sheet
---------------

* create and change to local reader branch tracking global reader branch: `git checkout --track -b reader origin/reader`
* create and change to a local branch (no tracking): `git checkout -b <branch>`
* change to a different branch: `git checkout <branch>`
* show list of branches: `git branch -av`
* make git use color when sensible: `git config --global color.ui auto`
* merge <branch> with reader: `git checkout reader; git merge <branch>`
* show a graphical summary of all history and refs: `git log --graph --all --pretty=oneline --decorate --abbrev-commit`

Architecture Ideas
==================

Here are some architecture ideas for people to think about:

1. IN Data -- data coming from the device to the host machine -- this
data could be coming in regularly and driven by the teensy
itself. Using the perrenial example of an ADC device, if someone opens
an ADC device (like /dev/adc0) then they will theoretically begin
reading at some point. So we should have the teensy begin sending
packets with samples.  These samples will come through an URB which
will trigger a call back function when completed. That callback
function will have to run in interrupt mode, grab the buffer of data
and do something sane with it while setting up the URB and
resubmitting it. That would look something like this psuedo-code:

	  a. check for error conditions
	  b. peek at the descriptor bytes of the data buffer
	  c. get the appropriate lock based on where the data is going
	  d. copy the data into the destination buffer
	  e. release the lock
	  f. wakeup an appropriate sleeper to handle the data
	  g. resubmit the URB and get out of the way.

2. Individual /dev/ devices -- if these are input devices, then they
need to have some kind of local buffer to queue data. The URB callback
from 1. above would have to get a lock on that buffer (I'm guessing an
array allocated ring buffer), and cram the data in. The device would
need to have a kthread or some kind of sleeper waiting for data in
that queue. When it gets awakened, it should chew through the whole
ring buffer until all the data is pushed out to the user. This will be
tricky, because we need a user to actually be reading (a blocked
read() call would be ideal for this). 
